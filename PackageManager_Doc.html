<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PackageManager API documentation</title>
<meta name="description" content="This module allows you to automatically import missing libraries (modules) that are required by any script without the need to any other installation …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PackageManager</code>&nbsp;<sub>v2.1.4</sub></h1>
</header>
<section id="section-intro">
<p>This module allows you to automatically import missing libraries (modules) that are required by any script without the need to any other installation or a requirement file.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
    Package Manager v2.0.0
    \n
    This module allows you to automatically import missing libraries (modules) that are required
    by any script without the need to any other installation or a requirement file.
    
    .. include:: ./README.md
&#34;&#34;&#34;

############ AUTHOURSHIP &amp; COPYRIGHTS ############
__author__      = &#34;Abdullrahman Elsayed&#34;
__copyright__   = &#34;Copyright 2022, Supportive Python Modules Project&#34;
__credits__     = &#34;Abdullrahman Elsayed&#34;
__license__     = &#34;MIT&#34;
__version__     = &#34;2.1.4&#34;
__maintainer__  = &#34;Abdullrahman Elsayed&#34;
__email__       = &#34;abdull15199@gmail.com&#34;
__status__      = &#34;Production&#34;
__doc__         = &#34;This module allows you to automatically import missing libraries (modules) that are required by any script without the need to any other installation or a requirement file.&#34;
##################################################

import ast, importlib.util, importlib.metadata, os, pkgutil, subprocess, sys

def PSL(Text: str, LastLine: bool = False) -&gt; None:
    &#34;&#34;&#34;
        Print on Same Line (PSL).\n
        Print multiple lines on the same line.

        ### Args:
            - Text (str): Text to be printed.
            - LastLine (bool, optional): If True, when you print after it, it will print in new line.

        ### Returns:
            None
    &#34;&#34;&#34;
    
    if (bool(LastLine)):
        sys.stdout.write(&#34;\r\033[K&#34; + Text + &#34;\n&#34;)
    else:
        sys.stdout.write(&#34;\r\033[K&#34; + Text)
    
    return None

class PackageManager:
    &#34;&#34;&#34;
        Main class of the module.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
            Constructor gets the main script file path and store class-scope variables
        &#34;&#34;&#34;

        # Class Variables
        self.__mainScript = sys.modules[&#39;__main__&#39;]
        self.__mainScriptPath = str((self.__mainScript.__file__).replace(&#39;\\&#39;, &#39;/&#39;))

        # User Accessable Variable
        self.STDPackages = tuple(list(sys.stdlib_module_names) + list(sys.builtin_module_names))
        self.InstalledPackages = tuple(self.__GetInstalledPackages())
        self.AccessiblePackages = tuple(self.STDPackages + self.InstalledPackages)
        self.RequiredPackages = tuple()
        self.AnalyzedPackages = set()

        # User Accessable Methods
        self.InstallPackage = lambda PackageName, PackageVersion, Verbose: \
            self.__InstallPackage(PackageName=str(PackageName), PackageVersion=str(PackageVersion), Verbose=bool(Verbose))
        
        self.GetImportedPackages = lambda PackagePath, IncludeDynamicImports, StrictSearch, Verbose: \
            self.__GetImportedPackages(PackagePath=PackagePath, IncludeDynamicImports=IncludeDynamicImports, StrictSearch=StrictSearch, Verbose=Verbose)

        self.UpgradePIP = lambda Verbose: self.__UpgradePIP(Verbose=bool(Verbose))

    ### INFORMATION RETRIVERS

    def __GetPackagePath(self, PackageName: str, IgnoreBuiltins: bool = False, Verbose: bool = False) -&gt; str | None:
        &#34;&#34;&#34;
            Searches and returns a package path using its name.

            ### Args:
                - PackageName (str): Target package name.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - str | None: Package file path if package exist, else, None will be returned.
        &#34;&#34;&#34;

        # Print progress to stdout
        if (bool(Verbose)): print(f&#34;Locating package &#39;{PackageName}&#39;...&#34;)
        
        # Load module without executing it
        module = importlib.util.find_spec(str(PackageName))

        # Check if module is found
        if (hasattr(module, &#39;origin&#39;)):
            module_path = str(module.origin)

            # Check if module has &#39;origin&#39; has a value which is not None
            if (str(module_path) != &#39;None&#39;):
                module_path = module_path
            
            # Check if module is not normally included in &#39;sys.path&#39; (has &#39;submodule_search_locations&#39; value)
            # and try to read its path
            elif (str(module_path) == &#39;None&#39;) \
            and (str(module.submodule_search_locations) != &#39;None&#39;):
                # Collecting path domain
                namespace = module.submodule_search_locations
                # Concatenate path domain
                module_path = str(f&#39;{namespace._path[0]}/{namespace._name}.py&#39;)
            
            else:
                module_path = None


        # Check if module is not found (if module == None)
        else:
            module_path = None

        # If &#39;IgnoreBuiltins&#39; is True, any built-in package will be returned as None
        if (bool(IgnoreBuiltins)) \
        and (module_path == &#39;built-in&#39;):
            module_path = None

        else:
            pass

        return module_path

    def __GetInstalledPackages(self, Verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
            Collects all packages (built-ins &amp; installed) accessible by Python.

            ### Args:
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - tuple: Names of all accessible packages (installed &amp; built-ins).
        &#34;&#34;&#34;

        # Print progress to stdout
        if (bool(Verbose)): print(&#34;Collecting Installed Packages...&#34;)

        # Retriving all &#39;sys&#39; accessible installed packages
        packages = [pkg.split(&#39;.&#39;)[0] for pkg in list(sys.modules) if pkg not in self.STDPackages]
        # print(set(packages))
        # exit()

        # Retriving other packages inaccessible by &#39;sys&#39;
        # Collect package names using &#39;..iter_modules()&#39;
        # Do not use &#39;..walk_packages()&#39;; it is slower than &#39;..iter_modules()&#39; because it retrives submodules as well
        # &#39;pkgutil.walk_packages()&#39; returns objects of modules, so we need to collect &#39;pkg.name&#39;
        for pkg in pkgutil.iter_modules():
            # Append to packages list
            packages.append(pkg.name)
        
        # Ensuring collected packages do not contain built-ins or std_libs as well as setting and sorting packages
        packages = sorted(set([pkg for pkg in packages if pkg not in self.STDPackages]))

        return tuple(packages)

    def __GetImportedPackages(self, PackagePath: str, IncludeDynamicImports: bool = True, StrictSearch: bool = False, Verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
            Collects imported packages from python code.\n
            #### IMPORT STATEMENTS INSIDE LOOPS CANNOT BE ACCESSED BY &#39;IncludeDynamicImports&#39;

            ### Args:
                - PackagePath (str): Python file path to be analyzed for imports.
                - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
                - StrictSearch (bool, optional): If enabled, only nodes containing the word &#39;import&#39; in their source code will be processed. Preferably keep it to default. Defaults to False.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - tuple: Names of imported modules by the code provided. If no imported modules found, an empty tuple will be returned.
        &#34;&#34;&#34;
        
        if (bool(Verbose)): PSL(f&#34;Collecting packages imported by &#39;{os.path.basename(PackagePath)}&#39;&#34;)

        def __getPackageSource(FilePath: str) -&gt; str:
            &#34;&#34;&#34;
                Reads source code from Python file

                ### Args:
                    - PackagePath (str): Python file absoulte path

                ### Raises:
                    - FileNotFoundError: If provided path is invalid or not a file

                ### Returns:
                    - str: Target file content
            &#34;&#34;&#34;
            # Check if provided parameter is a file path
            if (os.path.isfile(FilePath)):
                # Open and read content then return it
                with open(file=PackagePath, mode=&#39;r&#39;, errors=&#39;ignore&#39;) as source:
                    src_code = source.read()

            # If provided parameter is not a file, raise &#39;FileNotFoundError&#39;
            else:
                raise FileNotFoundError(f&#39;{FilePath} could not be found!&#39;)
            
            return src_code

        def __handleImport(Node: ast.Import) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported by &#39;import ...&#39;

                ### Args:
                    - Node (ast.Import): AST Import type node object

                ### Returns:
                    - tuple: Imported packages names
            &#34;&#34;&#34;

            # Assure &#39;Node&#39; type to process it
            if (type(Node) == ast.Import):
                # Collect packages names from Import Nodes
                pkgs = [getPkgName(pkg.name) for pkg in Node.names]
            
            else:
                # Return (None) if this is not an Import Node
                pkgs = [None]
            
            return tuple(pkgs)

        def __handleImportFrom(Node: ast.ImportFrom) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported by &#39;from ... import ...&#39;

                ### Args:
                    Node (ast.ImportFrom): AST ImportFrom type node object

                ### Returns:
                    tuple: Imported packages names
            &#34;&#34;&#34;
            
            # Assure &#39;Node&#39; type to process it
            if (type(Node) == ast.ImportFrom):
                # Collect packages names from From...Import Nodes
                module_name = Node.module

                # Check if module level, whether it is a parent directory or not &#39;e.g. from . import pkg ==&gt; level 1&#39; | &#39;e.g. from module import pkg ==&gt; level 0&#39;
                if (int(Node.level) == 0):
                    pkg = [getPkgName(Node.module)]
                else:
                    # If module is a parent directory, skip (pass as None)
                    pkg = [None]

            else:
                # Return (None) if this is not an ImportFrom Node
                pkg = [None]
            
            return tuple(pkg)

        def __handleAssign(Node: ast.Assign) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported dynamically by assignment &#39;e.g. variable = __import__(module)&#39;

                ### Args:
                    - Node (ast.Assign): AST Assign type node object

                ### Returns:
                    - tuple: Imported packages names
            &#34;&#34;&#34;

            # Assure &#39;Node&#39; type to process it
            if (type(Node) == ast.Assign):
                # Creating empty set to collect packages throughout the process
                pkgs = set()
                # Picking only functions assigned to a variable
                if (hasattr(Node.value, &#39;func&#39;)):
                    # Shorthanding &#39;Node.value.func&#39;
                    Node_func = Node.value.func
                    
                    # First if statement select directly called dynamic imports (e.g. import_module(module) or __import__(module))
                    # Second if statement select class.method called dynamic imports (e.g. importlib.import_module(module))
                    if ((hasattr(Node_func, &#39;id&#39;)) and (Node_func.id in [&#39;__import__&#39;, &#39;import_module&#39;])) \
                    or ((hasattr(Node_func, &#39;value&#39;)) and (Node_func.value.id in [&#39;importlib&#39;])):
                        
                        # Looping over import function arguments to collect modules passed as arguments
                        # This loop applies to positined argument assignment (e.g. __import__(module))
                        for arg in Node.value.args:
                            # Collecting argument value in the packages container
                            pkgs.add(getPkgName(arg.value))
                        
                        # This loop applies to referenced argument assignment (e.g. __import__(name=module))
                        for keyword in Node.value.keywords:
                            # Check if reference argument name == name (applies to &#39;__import__&#39; and &#39;importlib.import_module&#39;)
                            if (keyword.arg == &#39;name&#39;):
                                # Collecting argument value in the packages container
                                pkgs.add(getPkgName(keyword.value.value))
                    
                    else:
                        pass
                
                else:
                    pass
            
            else:
                # Return (None) if this is not an Assign Node
                pkgs = [None]

            return tuple(pkgs)
                
        def __handleExpr(Node: ast.Expr) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported dynamically by direct expression &#39;e.g. __import__(module)&#39;

                ### Args:
                    - Node (ast.Expr): AST Expr type node object

                ### Returns:
                    - tuple: Imported packages names
            &#34;&#34;&#34;
            
            # Assure &#39;Node&#39; type to process it
            # The second part of the if statment is used to ensure it catches only called functions not comments
            # The third part of the if statment ensures that the called import has valid argument value
            if (type(Node) == ast.Expr) \
            and (type(Node.value) == ast.Call) \
            and ((Node.value.args) or (Node.value.keywords)):
                # Creating empty set to collect packages throughout the process
                pkgs = set()

                # This loop applies to positined argument assignment (e.g. __import__(module))
                for arg in Node.value.args:
                    # Picking only directly called functions (|__import__) not functions assigned to variables
                    if (type(arg) == ast.Constant) \
                    and (hasattr(arg, &#39;value&#39;)):
                        # Adding module name to set container
                        pkgs.add(arg.value)
                
                # Applies to referenced argument assignment (e.g. __import__(name=module))
                for keyword in Node.value.keywords:
                    # Ensuring types appropriate for desired import calls (__import__(), importlib.import_module())
                    if (type(keyword.value) == ast.Constant) \
                    and (hasattr(keyword, &#39;value&#39;)):
                        # Adding module name to set container
                        pkgs.add(keyword.value.value)

            else:
                # Return (None) if this is not an Expr Node or the expression is not a function
                pkgs = [None]

            return tuple(pkgs)

        #region FuncBody

        # Extracting source code from target package file
        source_code = str(__getPackageSource(FilePath=PackagePath))

        # Parsed code into ast nodes
        parsed_code = ast.parse(source_code)

        # Shorthanding slicing dot-separated imports (e.g. import os.path)
        # and if pkg is somehow pass as None, return it as it is.
        # To be used in above functions
        getPkgName = lambda pkg: pkg.split(&#39;.&#39;)[0]

        # Two empty containers to collect initial and dynamic imports
        initial_imports = set()
        dynamic_imports = set()

        # If &#39;StrictSearch&#39; is enabled, only nodes containing the word &#39;import&#39; in their source code will be processed
        if (bool(StrictSearch)):
            code_nodes = [node for node in parsed_code.body if &#39;import&#39; in ast.get_source_segment(source=source_code, node=node)]
        else:
            code_nodes = parsed_code.body

        # Looping over code nodes
        for node in code_nodes:
            # The following if statments selects only Import, ImportFrom, Assign, and Expression nodes
            # from the provided code and process each node speacially.
            if   (type(node) == ast.Import):      initial_imports.update(__handleImport(Node=node))
            elif (type(node) == ast.ImportFrom):  initial_imports.update(__handleImportFrom(Node=node))
            elif (type(node) == ast.Assign):      dynamic_imports.update(__handleAssign(Node=node))
            elif (type(node) == ast.Expr):        dynamic_imports.update(__handleExpr(Node=node))
            # &#39;else&#39; here is set to pass to ignore every other node type
            else: pass
        
        # If &#39;IncludeDynamicImports&#39; is enabled, packages imported dynamically while the code runs will be collected.
        # This includes packages imported by &#39;__import__()&#39; and &#39;importlib.import_module()&#39;.
        # IMPORTS STATEMENTS INSIDE LOOPS WILL NOT BE PROCESSED
        if (bool(IncludeDynamicImports)):
            imports = set().union(initial_imports, dynamic_imports)
        else:
            imports = initial_imports

        # Check if imports has content. if yes, sort them, if no, set imports to None to indicate No Imports
        if (imports):
            # Neglecting every &#39;None&#39; element
            imports = [pkg for pkg in imports if str(pkg) != &#39;None&#39;]
            # Sorting the imports list
            imports = list(sorted(imports))
        else:
            imports = tuple()

        #endregion

        return tuple(imports)

    def __GetRequiredPackages(self, PackagePath: str, IncludeDynamicImports: bool = True, IncludePrivatePackages: bool = False, DeepScan: bool = False, Verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
            Collects all imported packages by a script and (optionally) imports of its imports,\n
            then tests wheather these packages are built-ins and std-lib packages or not.\n
            #### If you are working on a project with many relative imports, it is prefered to Enable &#39;DeepScan&#39;

            ### Args:
                - PackagePath (str): Python file path to be analyzed for imports.
                - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
                - IncludePrivatePackages (bool, optional): If enabled, packages names starting with &#39;_&#39; will be collected. PREFERABLY, DON&#39;T CHANGE DEFAULT. Defaults to False.
                - DeepScan (bool, optional): Scans imported scripts in target script for their own imports. Defaults to False.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - tuple: Packages imported but not installed or cannot be imported.
        &#34;&#34;&#34;

        # Collecting imported packages by module given its path &#39;PackagePath&#39;
        imported_packages = self.__GetImportedPackages(PackagePath=PackagePath, IncludeDynamicImports=IncludeDynamicImports, StrictSearch=True, Verbose=Verbose)
        # Getting project packages (packages in &#39;sys.modules&#39; but not in &#39;sys.stdlib_module_names&#39; or &#39;sys.builtin_module_names&#39;) or packages that are not installed
        project_main_imports = [pkg for pkg in imported_packages if pkg not in self.STDPackages]
        # &#39;required_packes&#39; is used as recursion container
        required_packages = set(imported_packages)

        # Check &#39;DeepScan&#39; state
        if (bool(DeepScan)):
            # Loop over project packages only.
            # System packages are not checked since we can check their requirements through pip,
            # also system packages would take very long time to check, which is unreliable.
            for pkg in project_main_imports:
                if (bool(Verbose)): PSL(f&#34;Analyzing packages imported by &#39;{pkg}&#39;&#34;)
                # Check if &#39;pkg&#39; not in &#39;self.AnalyzedPackages&#39;
                # &#39;self.AnalyzedPackages&#39; work as recursion terminator if all project packages are in it
                if (pkg not in self.AnalyzedPackages):
                    # Adding &#39;pkg&#39; to recursion termination list so it is not processed twice
                    self.AnalyzedPackages.add(pkg)

                    # Locating target &#39;pkg&#39; path
                    pkg_path = self.__GetPackagePath(PackageName=pkg, IgnoreBuiltins=True)

                    # Check if package has a path (not a built-in nor does not exist)
                    if (str(pkg_path) != &#39;None&#39;):
                        # Firing recursion #
                        # Recursion here works as follow:
                        # 1. &#39;pkg_path&#39; which is an imported package from &#39;__main__&#39; is checked for its own imports
                        # 2. Second time when the function reachs this recursion again, it checks the imported packages
                        #    in of package imported by &#39;__main__&#39; and so on.
                        # 3. Recursion is terminated when all sub-packages are checked for imports (when pkg_path is None)
                        recursion = self.__GetRequiredPackages(PackagePath=pkg_path, IncludeDynamicImports=IncludeDynamicImports, IncludePrivatePackages=IncludePrivatePackages, DeepScan=DeepScan)

                        # Updating &#39;required_packages&#39; with new imports from recursion to be carried out to next recursion loop
                        required_packages.update(recursion)
                    
                    # If package is None (built-in or does not exist), continue loop
                    else:
                        continue
                
                # If &#39;pkg&#39; in &#39;self.AnalyzedPackages&#39; (else is True),
                # the loop continues without analyzing current &#39;pkg&#39; since it must have been analyzed before
                else:
                    continue
        
        # If &#39;DeepScan&#39; is False, return only packages required by __main__
        else:
            if (bool(Verbose)): PSL(f&#34;Analyzing packages imported by &#39;{os.path.basename(PackagePath)}&#39;&#34;)
            pass
        
        if (bool(Verbose)): PSL(f&#34;Sorting required packages...&#34;)

        # Selecting only parent packages (by using &#39;pkg.split(&#39;.&#39;)[0]&#39;)
        required_packages = [pkg.split(&#39;.&#39;)[0] for pkg in required_packages]

        # Another filtration of &#39;requried_packages&#39;, removing built-in packages and packages already in &#39;sys.stdlib_module_names&#39; (a.k.a. &#39;self.STDPackages&#39;)
        required_packages = sorted(set([pkg for pkg in required_packages if pkg not in self.STDPackages]))

        # Selects either to include private modules (modules names starts with &#39;_&#39;) in required packages or not
        if (bool(IncludePrivatePackages)):
            pass
        else:
            # If &#39;IncludePrivatePackages&#39; is set to &#39;False&#39;, then private packages (packages start with _) will be excluded
            required_packages = [pkg for pkg in required_packages if (pkg.startswith(&#39;_&#39;) == False)]

        # Assigning return value to self.Variable
        self.RequiredPackages = tuple(required_packages)

        return tuple(required_packages)

    def __GetMissingPackages(self, PackagePath: str, IncludeDynamicImports: bool = True, IncludePrivatePackages: bool = False, DeepScan: bool = False, Verbose: bool = False) -&gt; tuple:
        # Collecting required packages by the project that are neither built-ins nor std_lib
        required_packages = self.__GetRequiredPackages(PackagePath=PackagePath, IncludeDynamicImports=IncludeDynamicImports, IncludePrivatePackages=IncludePrivatePackages, DeepScan=DeepScan, Verbose=Verbose)
        # Getting missing packages (packages not accessible in anyway)
        missed_main_imports = [pkg for pkg in required_packages if pkg not in self.AccessiblePackages]

        return tuple(missed_main_imports)

    ### ACTION MAKERS

    def __InstallPackage(self, PackageName: str, PackageVersion: str = &#34;latest&#34;, Verbose: bool = False) -&gt; dict:
        &#34;&#34;&#34;
            Installs specific package with desired version. If &#39;PackageVersion&#39; == None -&gt; latest version will be installed.

            ### Args:
                - PackageName (str): Exact package name to be installed.
                - PackageVersion (str, optional): Exact package version to be installed. Comparator operators are not allowed! Defaults to &#34;latest&#34;.
                - Verbose (bool, optional): Prints function progress.

            ### Returns:
                - dict: Return keys = ReturnMessage, ExitCode, ExitMessage
        &#34;&#34;&#34;

        # Check package version to be installed
        if (PackageVersion.replace(&#39;.&#39;,&#39;&#39;).isdigit()):
            target_package = f&#39;{str(PackageName)}=={str(PackageVersion)}&#39;
        else:
            target_package = str(PackageName)

        # Print progress to stdout
        if (bool(Verbose)): PSL(f&#39;Attempting to install &#34;{target_package}&#34;...&#39;)

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        installation_command = f&#39;&#34;{sys.executable}&#34; -m pip install {str(target_package)}&#39;
        installation_process = subprocess.Popen(str(installation_command), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return messages from executed command
        execution_message = str(installation_process.communicate())
        execution_exit_code = int(installation_process.wait())

        # Define function return messages based on execution return message
        if (execution_exit_code == 0):      # 0 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; has been installed successfully!&#39;
        elif (execution_exit_code == 1):    # 1 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; was not recognized, please consider installing it manually!&#39;
        else:                               # Other -&gt; Unknown Exit Code
            return_message = f&#39;Unexpected exit code ({execution_exit_code}) returned while installing &#34;{target_package}&#34;&#39;

        # Print progress to stdout
        if (bool(Verbose)): PSL(return_message, LastLine=True)
        
        return dict(
                {
                &#34;ReturnMessage&#34; : return_message,
                &#34;ExitCode&#34;      : execution_exit_code,
                &#34;ExitMessage&#34;   : execution_message
                }
            )

    # def __RemovePackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False):
    #     pass

    # def __UpgradePackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False):
    #     pass

    def __UpgradePIP(self, Verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
            Upgrade pip if an upgrade is available.

            ### Args:
                - Verbose (bool, optional): Prints function progress.

            ### Returns:
                - int: Exit Code {
                    * 0 : Successfully upgraded | No new version available
                    * 1 : An error occured
                    * 2 : Unknown exit code
                }
        &#34;&#34;&#34;

        def __getPIPVersion() -&gt; dict:
            # Retriving pip version
            execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip --version&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            pip_version_msg = execution.communicate()[0].decode(&#39;UTF-8&#39;)
            pip_version = pip_version_msg.split(&#39; &#39;)[1]

            return dict({
                &#39;version&#39;: pip_version,
                &#39;message&#39;: pip_version_msg
            })

        # Print progress to stdout
        if (bool(Verbose)): PSL(f&#39;Attempting to upgrade pip...&#39;)

        current_pip_version = __getPIPVersion()[&#39;version&#39;]

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip install --upgrade pip&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return code from executed command
        execution_exit_code = int(execution.wait())

        new_pip = __getPIPVersion()
        new_pip_version = new_pip[&#39;version&#39;]
        new_pip_message = new_pip[&#39;message&#39;].rstrip(&#39;\n&#39;)

        pip_is_new = int(new_pip_version.replace(&#39;.&#39;,&#39;&#39;)) &gt; int(current_pip_version.replace(&#39;.&#39;,&#39;&#39;))
        
        # Define function return messages based on execution return message
        if (execution_exit_code == 0) and pip_is_new:           # 0 -&gt; Successful Exit Code
            return_code = 0
            return_message = &#39;pip has been upgraded successfuly!&#39;

        elif (execution_exit_code == 0) and not pip_is_new:     # 0 -&gt; Successful Exit Code
            return_code = 0
            return_message = &#39;pip is already latest!&#39;

        elif (execution_exit_code == 1):  # 1 -&gt; Error Exit Code
            return_code = 1
            return_message = &#39;pip was not upgraded, please consider upgrading pip manually!&#39;

        else:                           # Other -&gt; Unknown Exit Code
            return_code = 2
            return_message = &#39;Unexpected exit code!&#39;

        # Print progress to stdout
        if (bool(Verbose)): PSL(f&#39;{return_message}\n{new_pip_message}&#39;, LastLine=True)

        return int(return_code)

    ### USER ACCESSIBLE

    # UNDER DEV
    def AutoImportMissings(self, IncludeDynamicImports: bool = True, DeepScan: bool = True, UpgradePIP: bool = False, Verbose: bool = False) -&gt; bool:
        &#34;&#34;&#34;
            Automatically analysis &#39;__main__&#39; script, update PIP, and installs required packages if missing.

            ### Args:
                - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
                - DeepScan (bool, optional): Scans imported scripts in target script for their own imports. Defaults to True.
                - UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages. Defaults to False.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - bool: returns True if all packages were successfully installed, else, False.
        &#34;&#34;&#34;

        failed_packages = set()

        missing_packages = self.__GetMissingPackages(PackagePath=self.__mainScriptPath, IncludeDynamicImports=IncludeDynamicImports, DeepScan=DeepScan, Verbose=Verbose)

        if (bool(UpgradePIP)): self.__UpgradePIP(Verbose=Verbose)

        for ind, pkg in enumerate(missing_packages, 1):
            if (bool(Verbose)): print(f&#34;\nInstalling Packages {ind}/{len(missing_packages)}&#34;)
            
            retry_counter = 1
            while (retry_counter &gt; 0):
                pkg_installer = self.__InstallPackage(PackageName=pkg, Verbose=Verbose)

                if (pkg_installer[&#39;ExitCode&#39;] == 0):
                    if (pkg in failed_packages):
                        failed_packages.remove(pkg)
                    else:
                        pass
                    
                    break

                else:
                    retry_counter -= 1
                    failed_packages.add(pkg)
        
        if (len(failed_packages) &gt; 0):
            print(f&#39;\nCOULD NOT INSTALL THESE PACKAGES: ({&#34;, &#34;.join(failed_packages)})!\nPLEASE CONSIDER INSTALLING THEM MANUALLY!\n&#39;)

            while True:
                decision = input(&#39;Would you like to continue executing your code? *IT WILL PROBABLY RAISE AN ERROR IF YOU CONTINUE..* (Y/n) &#39;)

                if (decision == &#39;Y&#39;):
                    print()
                    return False
                elif (decision == &#39;n&#39;):
                    exit()
                else:
                    print(&#39;Invalid input!&#39;)
        elif (str(missing_packages) == &#39;None&#39;) \
        or (len(missing_packages) == 0):
            print(f&#39;\nNo missing required packages were found!\n&#39;)
        
        else:
            print(f&#39;\nRequired missing packages have been installed successfully!\n&#39;)

    # UNDER DEV
    def ExportRequirements(self, ExportTo__main__Dir: str | bool = False) -&gt; dict:
        &#34;&#34;&#34;
            Exports a requirement file contains modules required by the project which this method is called in.

            ### Args:
                - ExportTo__main__Dir (str | bool, optional): This argument has three modes as explained below.\n
                    * Mode 1: If set to bool(False), will not export to file and will only return a dict of packages and their versions. (Default)
                    * Mode 2: If set to bool(True), will export requirements.txt file to parent directory of __main__ file.
                    * Mode 3: If set to a valid directory str(path), will export requirement.txt to specified directory.

            ### Returns:
                - dict: Dict of packages names and versions (possible keys for each value =&gt; &#39;name&#39;, &#39;version&#39;)
        &#34;&#34;&#34;

        project_dir_path = os.path.dirname(self.__mainScriptPath)
        pkgs = self.__GetRequiredPackages(self.__mainScriptPath, DeepScan=True)
        reqs = []

        for pkg in pkgs:
            if project_dir_path not in self.__GetPackagePath(pkg):
                reqs.append(pkg + &#34;==&#34; + importlib.metadata.version(pkg))
            else:
                pass
        
        reqs.insert(0, __name__ + &#39;==&#39; + __version__)
        
        reqs_dict = {pkg: {&#39;name&#39;: pkg, &#39;version&#39;: ver} for pkg, ver in [req.split(&#39;==&#39;) for req in reqs]}

        if (bool(os.path.isdir(ExportTo__main__Dir))):
            project_dir_path = ExportTo__main__Dir.replace(&#39;&#34;&#39;, &#39;&#39;).replace(&#34;&#39;&#34;, &#39;&#39;).replace(&#39;\\&#39;, &#39;/&#39;)
        else:
            pass
            
        
        if (bool(os.path.isdir(project_dir_path))) \
        and (bool(ExportTo__main__Dir)):
            with open(f&#39;{project_dir_path}/requirements-by-{os.path.basename(self.__mainScript.__file__)}.txt&#39;, &#39;w&#39;) as req_file:
                for pkg in reqs:
                    req_file.write(pkg + &#39;\n&#39;)
        else:
            pass
            
        return reqs_dict

class AutoImporter:
    &#34;&#34;&#34;
        Auto Imports missing required modules.\n
        This class is riggered by importing it.
    &#34;&#34;&#34;
    # Call AutoImportMissings as a variable value so that it is triggered as soon as the class AutoImporter is imported
    if __name__ != &#39;__main__&#39;:
        PackageManager().AutoImportMissings(IncludeDynamicImports=True, DeepScan=True, UpgradePIP=False, Verbose=True)
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PackageManager.PSL"><code class="name flex">
<span>def <span class="ident">PSL</span></span>(<span>Text: str, LastLine: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Print on Same Line (PSL).</p>
<p>Print multiple lines on the same line.</p>
<h3 id="args">Args:</h3>
<pre><code>- Text (str): Text to be printed.
- LastLine (bool, optional): If True, when you print after it, it will print in new line.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PSL(Text: str, LastLine: bool = False) -&gt; None:
    &#34;&#34;&#34;
        Print on Same Line (PSL).\n
        Print multiple lines on the same line.

        ### Args:
            - Text (str): Text to be printed.
            - LastLine (bool, optional): If True, when you print after it, it will print in new line.

        ### Returns:
            None
    &#34;&#34;&#34;
    
    if (bool(LastLine)):
        sys.stdout.write(&#34;\r\033[K&#34; + Text + &#34;\n&#34;)
    else:
        sys.stdout.write(&#34;\r\033[K&#34; + Text)
    
    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PackageManager.AutoImporter"><code class="flex name class">
<span>class <span class="ident">AutoImporter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Auto Imports missing required modules.</p>
<p>This class is riggered by importing it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutoImporter:
    &#34;&#34;&#34;
        Auto Imports missing required modules.\n
        This class is riggered by importing it.
    &#34;&#34;&#34;
    # Call AutoImportMissings as a variable value so that it is triggered as soon as the class AutoImporter is imported
    if __name__ != &#39;__main__&#39;:
        PackageManager().AutoImportMissings(IncludeDynamicImports=True, DeepScan=True, UpgradePIP=False, Verbose=True)</code></pre>
</details>
</dd>
<dt id="PackageManager.PackageManager"><code class="flex name class">
<span>class <span class="ident">PackageManager</span></span>
</code></dt>
<dd>
<div class="desc"><p>Main class of the module.</p>
<p>Constructor gets the main script file path and store class-scope variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PackageManager:
    &#34;&#34;&#34;
        Main class of the module.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
            Constructor gets the main script file path and store class-scope variables
        &#34;&#34;&#34;

        # Class Variables
        self.__mainScript = sys.modules[&#39;__main__&#39;]
        self.__mainScriptPath = str((self.__mainScript.__file__).replace(&#39;\\&#39;, &#39;/&#39;))

        # User Accessable Variable
        self.STDPackages = tuple(list(sys.stdlib_module_names) + list(sys.builtin_module_names))
        self.InstalledPackages = tuple(self.__GetInstalledPackages())
        self.AccessiblePackages = tuple(self.STDPackages + self.InstalledPackages)
        self.RequiredPackages = tuple()
        self.AnalyzedPackages = set()

        # User Accessable Methods
        self.InstallPackage = lambda PackageName, PackageVersion, Verbose: \
            self.__InstallPackage(PackageName=str(PackageName), PackageVersion=str(PackageVersion), Verbose=bool(Verbose))
        
        self.GetImportedPackages = lambda PackagePath, IncludeDynamicImports, StrictSearch, Verbose: \
            self.__GetImportedPackages(PackagePath=PackagePath, IncludeDynamicImports=IncludeDynamicImports, StrictSearch=StrictSearch, Verbose=Verbose)

        self.UpgradePIP = lambda Verbose: self.__UpgradePIP(Verbose=bool(Verbose))

    ### INFORMATION RETRIVERS

    def __GetPackagePath(self, PackageName: str, IgnoreBuiltins: bool = False, Verbose: bool = False) -&gt; str | None:
        &#34;&#34;&#34;
            Searches and returns a package path using its name.

            ### Args:
                - PackageName (str): Target package name.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - str | None: Package file path if package exist, else, None will be returned.
        &#34;&#34;&#34;

        # Print progress to stdout
        if (bool(Verbose)): print(f&#34;Locating package &#39;{PackageName}&#39;...&#34;)
        
        # Load module without executing it
        module = importlib.util.find_spec(str(PackageName))

        # Check if module is found
        if (hasattr(module, &#39;origin&#39;)):
            module_path = str(module.origin)

            # Check if module has &#39;origin&#39; has a value which is not None
            if (str(module_path) != &#39;None&#39;):
                module_path = module_path
            
            # Check if module is not normally included in &#39;sys.path&#39; (has &#39;submodule_search_locations&#39; value)
            # and try to read its path
            elif (str(module_path) == &#39;None&#39;) \
            and (str(module.submodule_search_locations) != &#39;None&#39;):
                # Collecting path domain
                namespace = module.submodule_search_locations
                # Concatenate path domain
                module_path = str(f&#39;{namespace._path[0]}/{namespace._name}.py&#39;)
            
            else:
                module_path = None


        # Check if module is not found (if module == None)
        else:
            module_path = None

        # If &#39;IgnoreBuiltins&#39; is True, any built-in package will be returned as None
        if (bool(IgnoreBuiltins)) \
        and (module_path == &#39;built-in&#39;):
            module_path = None

        else:
            pass

        return module_path

    def __GetInstalledPackages(self, Verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
            Collects all packages (built-ins &amp; installed) accessible by Python.

            ### Args:
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - tuple: Names of all accessible packages (installed &amp; built-ins).
        &#34;&#34;&#34;

        # Print progress to stdout
        if (bool(Verbose)): print(&#34;Collecting Installed Packages...&#34;)

        # Retriving all &#39;sys&#39; accessible installed packages
        packages = [pkg.split(&#39;.&#39;)[0] for pkg in list(sys.modules) if pkg not in self.STDPackages]
        # print(set(packages))
        # exit()

        # Retriving other packages inaccessible by &#39;sys&#39;
        # Collect package names using &#39;..iter_modules()&#39;
        # Do not use &#39;..walk_packages()&#39;; it is slower than &#39;..iter_modules()&#39; because it retrives submodules as well
        # &#39;pkgutil.walk_packages()&#39; returns objects of modules, so we need to collect &#39;pkg.name&#39;
        for pkg in pkgutil.iter_modules():
            # Append to packages list
            packages.append(pkg.name)
        
        # Ensuring collected packages do not contain built-ins or std_libs as well as setting and sorting packages
        packages = sorted(set([pkg for pkg in packages if pkg not in self.STDPackages]))

        return tuple(packages)

    def __GetImportedPackages(self, PackagePath: str, IncludeDynamicImports: bool = True, StrictSearch: bool = False, Verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
            Collects imported packages from python code.\n
            #### IMPORT STATEMENTS INSIDE LOOPS CANNOT BE ACCESSED BY &#39;IncludeDynamicImports&#39;

            ### Args:
                - PackagePath (str): Python file path to be analyzed for imports.
                - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
                - StrictSearch (bool, optional): If enabled, only nodes containing the word &#39;import&#39; in their source code will be processed. Preferably keep it to default. Defaults to False.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - tuple: Names of imported modules by the code provided. If no imported modules found, an empty tuple will be returned.
        &#34;&#34;&#34;
        
        if (bool(Verbose)): PSL(f&#34;Collecting packages imported by &#39;{os.path.basename(PackagePath)}&#39;&#34;)

        def __getPackageSource(FilePath: str) -&gt; str:
            &#34;&#34;&#34;
                Reads source code from Python file

                ### Args:
                    - PackagePath (str): Python file absoulte path

                ### Raises:
                    - FileNotFoundError: If provided path is invalid or not a file

                ### Returns:
                    - str: Target file content
            &#34;&#34;&#34;
            # Check if provided parameter is a file path
            if (os.path.isfile(FilePath)):
                # Open and read content then return it
                with open(file=PackagePath, mode=&#39;r&#39;, errors=&#39;ignore&#39;) as source:
                    src_code = source.read()

            # If provided parameter is not a file, raise &#39;FileNotFoundError&#39;
            else:
                raise FileNotFoundError(f&#39;{FilePath} could not be found!&#39;)
            
            return src_code

        def __handleImport(Node: ast.Import) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported by &#39;import ...&#39;

                ### Args:
                    - Node (ast.Import): AST Import type node object

                ### Returns:
                    - tuple: Imported packages names
            &#34;&#34;&#34;

            # Assure &#39;Node&#39; type to process it
            if (type(Node) == ast.Import):
                # Collect packages names from Import Nodes
                pkgs = [getPkgName(pkg.name) for pkg in Node.names]
            
            else:
                # Return (None) if this is not an Import Node
                pkgs = [None]
            
            return tuple(pkgs)

        def __handleImportFrom(Node: ast.ImportFrom) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported by &#39;from ... import ...&#39;

                ### Args:
                    Node (ast.ImportFrom): AST ImportFrom type node object

                ### Returns:
                    tuple: Imported packages names
            &#34;&#34;&#34;
            
            # Assure &#39;Node&#39; type to process it
            if (type(Node) == ast.ImportFrom):
                # Collect packages names from From...Import Nodes
                module_name = Node.module

                # Check if module level, whether it is a parent directory or not &#39;e.g. from . import pkg ==&gt; level 1&#39; | &#39;e.g. from module import pkg ==&gt; level 0&#39;
                if (int(Node.level) == 0):
                    pkg = [getPkgName(Node.module)]
                else:
                    # If module is a parent directory, skip (pass as None)
                    pkg = [None]

            else:
                # Return (None) if this is not an ImportFrom Node
                pkg = [None]
            
            return tuple(pkg)

        def __handleAssign(Node: ast.Assign) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported dynamically by assignment &#39;e.g. variable = __import__(module)&#39;

                ### Args:
                    - Node (ast.Assign): AST Assign type node object

                ### Returns:
                    - tuple: Imported packages names
            &#34;&#34;&#34;

            # Assure &#39;Node&#39; type to process it
            if (type(Node) == ast.Assign):
                # Creating empty set to collect packages throughout the process
                pkgs = set()
                # Picking only functions assigned to a variable
                if (hasattr(Node.value, &#39;func&#39;)):
                    # Shorthanding &#39;Node.value.func&#39;
                    Node_func = Node.value.func
                    
                    # First if statement select directly called dynamic imports (e.g. import_module(module) or __import__(module))
                    # Second if statement select class.method called dynamic imports (e.g. importlib.import_module(module))
                    if ((hasattr(Node_func, &#39;id&#39;)) and (Node_func.id in [&#39;__import__&#39;, &#39;import_module&#39;])) \
                    or ((hasattr(Node_func, &#39;value&#39;)) and (Node_func.value.id in [&#39;importlib&#39;])):
                        
                        # Looping over import function arguments to collect modules passed as arguments
                        # This loop applies to positined argument assignment (e.g. __import__(module))
                        for arg in Node.value.args:
                            # Collecting argument value in the packages container
                            pkgs.add(getPkgName(arg.value))
                        
                        # This loop applies to referenced argument assignment (e.g. __import__(name=module))
                        for keyword in Node.value.keywords:
                            # Check if reference argument name == name (applies to &#39;__import__&#39; and &#39;importlib.import_module&#39;)
                            if (keyword.arg == &#39;name&#39;):
                                # Collecting argument value in the packages container
                                pkgs.add(getPkgName(keyword.value.value))
                    
                    else:
                        pass
                
                else:
                    pass
            
            else:
                # Return (None) if this is not an Assign Node
                pkgs = [None]

            return tuple(pkgs)
                
        def __handleExpr(Node: ast.Expr) -&gt; tuple:
            &#34;&#34;&#34;
                Collects packages names imported dynamically by direct expression &#39;e.g. __import__(module)&#39;

                ### Args:
                    - Node (ast.Expr): AST Expr type node object

                ### Returns:
                    - tuple: Imported packages names
            &#34;&#34;&#34;
            
            # Assure &#39;Node&#39; type to process it
            # The second part of the if statment is used to ensure it catches only called functions not comments
            # The third part of the if statment ensures that the called import has valid argument value
            if (type(Node) == ast.Expr) \
            and (type(Node.value) == ast.Call) \
            and ((Node.value.args) or (Node.value.keywords)):
                # Creating empty set to collect packages throughout the process
                pkgs = set()

                # This loop applies to positined argument assignment (e.g. __import__(module))
                for arg in Node.value.args:
                    # Picking only directly called functions (|__import__) not functions assigned to variables
                    if (type(arg) == ast.Constant) \
                    and (hasattr(arg, &#39;value&#39;)):
                        # Adding module name to set container
                        pkgs.add(arg.value)
                
                # Applies to referenced argument assignment (e.g. __import__(name=module))
                for keyword in Node.value.keywords:
                    # Ensuring types appropriate for desired import calls (__import__(), importlib.import_module())
                    if (type(keyword.value) == ast.Constant) \
                    and (hasattr(keyword, &#39;value&#39;)):
                        # Adding module name to set container
                        pkgs.add(keyword.value.value)

            else:
                # Return (None) if this is not an Expr Node or the expression is not a function
                pkgs = [None]

            return tuple(pkgs)

        #region FuncBody

        # Extracting source code from target package file
        source_code = str(__getPackageSource(FilePath=PackagePath))

        # Parsed code into ast nodes
        parsed_code = ast.parse(source_code)

        # Shorthanding slicing dot-separated imports (e.g. import os.path)
        # and if pkg is somehow pass as None, return it as it is.
        # To be used in above functions
        getPkgName = lambda pkg: pkg.split(&#39;.&#39;)[0]

        # Two empty containers to collect initial and dynamic imports
        initial_imports = set()
        dynamic_imports = set()

        # If &#39;StrictSearch&#39; is enabled, only nodes containing the word &#39;import&#39; in their source code will be processed
        if (bool(StrictSearch)):
            code_nodes = [node for node in parsed_code.body if &#39;import&#39; in ast.get_source_segment(source=source_code, node=node)]
        else:
            code_nodes = parsed_code.body

        # Looping over code nodes
        for node in code_nodes:
            # The following if statments selects only Import, ImportFrom, Assign, and Expression nodes
            # from the provided code and process each node speacially.
            if   (type(node) == ast.Import):      initial_imports.update(__handleImport(Node=node))
            elif (type(node) == ast.ImportFrom):  initial_imports.update(__handleImportFrom(Node=node))
            elif (type(node) == ast.Assign):      dynamic_imports.update(__handleAssign(Node=node))
            elif (type(node) == ast.Expr):        dynamic_imports.update(__handleExpr(Node=node))
            # &#39;else&#39; here is set to pass to ignore every other node type
            else: pass
        
        # If &#39;IncludeDynamicImports&#39; is enabled, packages imported dynamically while the code runs will be collected.
        # This includes packages imported by &#39;__import__()&#39; and &#39;importlib.import_module()&#39;.
        # IMPORTS STATEMENTS INSIDE LOOPS WILL NOT BE PROCESSED
        if (bool(IncludeDynamicImports)):
            imports = set().union(initial_imports, dynamic_imports)
        else:
            imports = initial_imports

        # Check if imports has content. if yes, sort them, if no, set imports to None to indicate No Imports
        if (imports):
            # Neglecting every &#39;None&#39; element
            imports = [pkg for pkg in imports if str(pkg) != &#39;None&#39;]
            # Sorting the imports list
            imports = list(sorted(imports))
        else:
            imports = tuple()

        #endregion

        return tuple(imports)

    def __GetRequiredPackages(self, PackagePath: str, IncludeDynamicImports: bool = True, IncludePrivatePackages: bool = False, DeepScan: bool = False, Verbose: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
            Collects all imported packages by a script and (optionally) imports of its imports,\n
            then tests wheather these packages are built-ins and std-lib packages or not.\n
            #### If you are working on a project with many relative imports, it is prefered to Enable &#39;DeepScan&#39;

            ### Args:
                - PackagePath (str): Python file path to be analyzed for imports.
                - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
                - IncludePrivatePackages (bool, optional): If enabled, packages names starting with &#39;_&#39; will be collected. PREFERABLY, DON&#39;T CHANGE DEFAULT. Defaults to False.
                - DeepScan (bool, optional): Scans imported scripts in target script for their own imports. Defaults to False.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - tuple: Packages imported but not installed or cannot be imported.
        &#34;&#34;&#34;

        # Collecting imported packages by module given its path &#39;PackagePath&#39;
        imported_packages = self.__GetImportedPackages(PackagePath=PackagePath, IncludeDynamicImports=IncludeDynamicImports, StrictSearch=True, Verbose=Verbose)
        # Getting project packages (packages in &#39;sys.modules&#39; but not in &#39;sys.stdlib_module_names&#39; or &#39;sys.builtin_module_names&#39;) or packages that are not installed
        project_main_imports = [pkg for pkg in imported_packages if pkg not in self.STDPackages]
        # &#39;required_packes&#39; is used as recursion container
        required_packages = set(imported_packages)

        # Check &#39;DeepScan&#39; state
        if (bool(DeepScan)):
            # Loop over project packages only.
            # System packages are not checked since we can check their requirements through pip,
            # also system packages would take very long time to check, which is unreliable.
            for pkg in project_main_imports:
                if (bool(Verbose)): PSL(f&#34;Analyzing packages imported by &#39;{pkg}&#39;&#34;)
                # Check if &#39;pkg&#39; not in &#39;self.AnalyzedPackages&#39;
                # &#39;self.AnalyzedPackages&#39; work as recursion terminator if all project packages are in it
                if (pkg not in self.AnalyzedPackages):
                    # Adding &#39;pkg&#39; to recursion termination list so it is not processed twice
                    self.AnalyzedPackages.add(pkg)

                    # Locating target &#39;pkg&#39; path
                    pkg_path = self.__GetPackagePath(PackageName=pkg, IgnoreBuiltins=True)

                    # Check if package has a path (not a built-in nor does not exist)
                    if (str(pkg_path) != &#39;None&#39;):
                        # Firing recursion #
                        # Recursion here works as follow:
                        # 1. &#39;pkg_path&#39; which is an imported package from &#39;__main__&#39; is checked for its own imports
                        # 2. Second time when the function reachs this recursion again, it checks the imported packages
                        #    in of package imported by &#39;__main__&#39; and so on.
                        # 3. Recursion is terminated when all sub-packages are checked for imports (when pkg_path is None)
                        recursion = self.__GetRequiredPackages(PackagePath=pkg_path, IncludeDynamicImports=IncludeDynamicImports, IncludePrivatePackages=IncludePrivatePackages, DeepScan=DeepScan)

                        # Updating &#39;required_packages&#39; with new imports from recursion to be carried out to next recursion loop
                        required_packages.update(recursion)
                    
                    # If package is None (built-in or does not exist), continue loop
                    else:
                        continue
                
                # If &#39;pkg&#39; in &#39;self.AnalyzedPackages&#39; (else is True),
                # the loop continues without analyzing current &#39;pkg&#39; since it must have been analyzed before
                else:
                    continue
        
        # If &#39;DeepScan&#39; is False, return only packages required by __main__
        else:
            if (bool(Verbose)): PSL(f&#34;Analyzing packages imported by &#39;{os.path.basename(PackagePath)}&#39;&#34;)
            pass
        
        if (bool(Verbose)): PSL(f&#34;Sorting required packages...&#34;)

        # Selecting only parent packages (by using &#39;pkg.split(&#39;.&#39;)[0]&#39;)
        required_packages = [pkg.split(&#39;.&#39;)[0] for pkg in required_packages]

        # Another filtration of &#39;requried_packages&#39;, removing built-in packages and packages already in &#39;sys.stdlib_module_names&#39; (a.k.a. &#39;self.STDPackages&#39;)
        required_packages = sorted(set([pkg for pkg in required_packages if pkg not in self.STDPackages]))

        # Selects either to include private modules (modules names starts with &#39;_&#39;) in required packages or not
        if (bool(IncludePrivatePackages)):
            pass
        else:
            # If &#39;IncludePrivatePackages&#39; is set to &#39;False&#39;, then private packages (packages start with _) will be excluded
            required_packages = [pkg for pkg in required_packages if (pkg.startswith(&#39;_&#39;) == False)]

        # Assigning return value to self.Variable
        self.RequiredPackages = tuple(required_packages)

        return tuple(required_packages)

    def __GetMissingPackages(self, PackagePath: str, IncludeDynamicImports: bool = True, IncludePrivatePackages: bool = False, DeepScan: bool = False, Verbose: bool = False) -&gt; tuple:
        # Collecting required packages by the project that are neither built-ins nor std_lib
        required_packages = self.__GetRequiredPackages(PackagePath=PackagePath, IncludeDynamicImports=IncludeDynamicImports, IncludePrivatePackages=IncludePrivatePackages, DeepScan=DeepScan, Verbose=Verbose)
        # Getting missing packages (packages not accessible in anyway)
        missed_main_imports = [pkg for pkg in required_packages if pkg not in self.AccessiblePackages]

        return tuple(missed_main_imports)

    ### ACTION MAKERS

    def __InstallPackage(self, PackageName: str, PackageVersion: str = &#34;latest&#34;, Verbose: bool = False) -&gt; dict:
        &#34;&#34;&#34;
            Installs specific package with desired version. If &#39;PackageVersion&#39; == None -&gt; latest version will be installed.

            ### Args:
                - PackageName (str): Exact package name to be installed.
                - PackageVersion (str, optional): Exact package version to be installed. Comparator operators are not allowed! Defaults to &#34;latest&#34;.
                - Verbose (bool, optional): Prints function progress.

            ### Returns:
                - dict: Return keys = ReturnMessage, ExitCode, ExitMessage
        &#34;&#34;&#34;

        # Check package version to be installed
        if (PackageVersion.replace(&#39;.&#39;,&#39;&#39;).isdigit()):
            target_package = f&#39;{str(PackageName)}=={str(PackageVersion)}&#39;
        else:
            target_package = str(PackageName)

        # Print progress to stdout
        if (bool(Verbose)): PSL(f&#39;Attempting to install &#34;{target_package}&#34;...&#39;)

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        installation_command = f&#39;&#34;{sys.executable}&#34; -m pip install {str(target_package)}&#39;
        installation_process = subprocess.Popen(str(installation_command), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return messages from executed command
        execution_message = str(installation_process.communicate())
        execution_exit_code = int(installation_process.wait())

        # Define function return messages based on execution return message
        if (execution_exit_code == 0):      # 0 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; has been installed successfully!&#39;
        elif (execution_exit_code == 1):    # 1 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; was not recognized, please consider installing it manually!&#39;
        else:                               # Other -&gt; Unknown Exit Code
            return_message = f&#39;Unexpected exit code ({execution_exit_code}) returned while installing &#34;{target_package}&#34;&#39;

        # Print progress to stdout
        if (bool(Verbose)): PSL(return_message, LastLine=True)
        
        return dict(
                {
                &#34;ReturnMessage&#34; : return_message,
                &#34;ExitCode&#34;      : execution_exit_code,
                &#34;ExitMessage&#34;   : execution_message
                }
            )

    # def __RemovePackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False):
    #     pass

    # def __UpgradePackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False):
    #     pass

    def __UpgradePIP(self, Verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
            Upgrade pip if an upgrade is available.

            ### Args:
                - Verbose (bool, optional): Prints function progress.

            ### Returns:
                - int: Exit Code {
                    * 0 : Successfully upgraded | No new version available
                    * 1 : An error occured
                    * 2 : Unknown exit code
                }
        &#34;&#34;&#34;

        def __getPIPVersion() -&gt; dict:
            # Retriving pip version
            execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip --version&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            pip_version_msg = execution.communicate()[0].decode(&#39;UTF-8&#39;)
            pip_version = pip_version_msg.split(&#39; &#39;)[1]

            return dict({
                &#39;version&#39;: pip_version,
                &#39;message&#39;: pip_version_msg
            })

        # Print progress to stdout
        if (bool(Verbose)): PSL(f&#39;Attempting to upgrade pip...&#39;)

        current_pip_version = __getPIPVersion()[&#39;version&#39;]

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip install --upgrade pip&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return code from executed command
        execution_exit_code = int(execution.wait())

        new_pip = __getPIPVersion()
        new_pip_version = new_pip[&#39;version&#39;]
        new_pip_message = new_pip[&#39;message&#39;].rstrip(&#39;\n&#39;)

        pip_is_new = int(new_pip_version.replace(&#39;.&#39;,&#39;&#39;)) &gt; int(current_pip_version.replace(&#39;.&#39;,&#39;&#39;))
        
        # Define function return messages based on execution return message
        if (execution_exit_code == 0) and pip_is_new:           # 0 -&gt; Successful Exit Code
            return_code = 0
            return_message = &#39;pip has been upgraded successfuly!&#39;

        elif (execution_exit_code == 0) and not pip_is_new:     # 0 -&gt; Successful Exit Code
            return_code = 0
            return_message = &#39;pip is already latest!&#39;

        elif (execution_exit_code == 1):  # 1 -&gt; Error Exit Code
            return_code = 1
            return_message = &#39;pip was not upgraded, please consider upgrading pip manually!&#39;

        else:                           # Other -&gt; Unknown Exit Code
            return_code = 2
            return_message = &#39;Unexpected exit code!&#39;

        # Print progress to stdout
        if (bool(Verbose)): PSL(f&#39;{return_message}\n{new_pip_message}&#39;, LastLine=True)

        return int(return_code)

    ### USER ACCESSIBLE

    # UNDER DEV
    def AutoImportMissings(self, IncludeDynamicImports: bool = True, DeepScan: bool = True, UpgradePIP: bool = False, Verbose: bool = False) -&gt; bool:
        &#34;&#34;&#34;
            Automatically analysis &#39;__main__&#39; script, update PIP, and installs required packages if missing.

            ### Args:
                - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
                - DeepScan (bool, optional): Scans imported scripts in target script for their own imports. Defaults to True.
                - UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages. Defaults to False.
                - Verbose (bool, optional): Prints function progress. Defaults to False.

            ### Returns:
                - bool: returns True if all packages were successfully installed, else, False.
        &#34;&#34;&#34;

        failed_packages = set()

        missing_packages = self.__GetMissingPackages(PackagePath=self.__mainScriptPath, IncludeDynamicImports=IncludeDynamicImports, DeepScan=DeepScan, Verbose=Verbose)

        if (bool(UpgradePIP)): self.__UpgradePIP(Verbose=Verbose)

        for ind, pkg in enumerate(missing_packages, 1):
            if (bool(Verbose)): print(f&#34;\nInstalling Packages {ind}/{len(missing_packages)}&#34;)
            
            retry_counter = 1
            while (retry_counter &gt; 0):
                pkg_installer = self.__InstallPackage(PackageName=pkg, Verbose=Verbose)

                if (pkg_installer[&#39;ExitCode&#39;] == 0):
                    if (pkg in failed_packages):
                        failed_packages.remove(pkg)
                    else:
                        pass
                    
                    break

                else:
                    retry_counter -= 1
                    failed_packages.add(pkg)
        
        if (len(failed_packages) &gt; 0):
            print(f&#39;\nCOULD NOT INSTALL THESE PACKAGES: ({&#34;, &#34;.join(failed_packages)})!\nPLEASE CONSIDER INSTALLING THEM MANUALLY!\n&#39;)

            while True:
                decision = input(&#39;Would you like to continue executing your code? *IT WILL PROBABLY RAISE AN ERROR IF YOU CONTINUE..* (Y/n) &#39;)

                if (decision == &#39;Y&#39;):
                    print()
                    return False
                elif (decision == &#39;n&#39;):
                    exit()
                else:
                    print(&#39;Invalid input!&#39;)
        elif (str(missing_packages) == &#39;None&#39;) \
        or (len(missing_packages) == 0):
            print(f&#39;\nNo missing required packages were found!\n&#39;)
        
        else:
            print(f&#39;\nRequired missing packages have been installed successfully!\n&#39;)

    # UNDER DEV
    def ExportRequirements(self, ExportTo__main__Dir: str | bool = False) -&gt; dict:
        &#34;&#34;&#34;
            Exports a requirement file contains modules required by the project which this method is called in.

            ### Args:
                - ExportTo__main__Dir (str | bool, optional): This argument has three modes as explained below.\n
                    * Mode 1: If set to bool(False), will not export to file and will only return a dict of packages and their versions. (Default)
                    * Mode 2: If set to bool(True), will export requirements.txt file to parent directory of __main__ file.
                    * Mode 3: If set to a valid directory str(path), will export requirement.txt to specified directory.

            ### Returns:
                - dict: Dict of packages names and versions (possible keys for each value =&gt; &#39;name&#39;, &#39;version&#39;)
        &#34;&#34;&#34;

        project_dir_path = os.path.dirname(self.__mainScriptPath)
        pkgs = self.__GetRequiredPackages(self.__mainScriptPath, DeepScan=True)
        reqs = []

        for pkg in pkgs:
            if project_dir_path not in self.__GetPackagePath(pkg):
                reqs.append(pkg + &#34;==&#34; + importlib.metadata.version(pkg))
            else:
                pass
        
        reqs.insert(0, __name__ + &#39;==&#39; + __version__)
        
        reqs_dict = {pkg: {&#39;name&#39;: pkg, &#39;version&#39;: ver} for pkg, ver in [req.split(&#39;==&#39;) for req in reqs]}

        if (bool(os.path.isdir(ExportTo__main__Dir))):
            project_dir_path = ExportTo__main__Dir.replace(&#39;&#34;&#39;, &#39;&#39;).replace(&#34;&#39;&#34;, &#39;&#39;).replace(&#39;\\&#39;, &#39;/&#39;)
        else:
            pass
            
        
        if (bool(os.path.isdir(project_dir_path))) \
        and (bool(ExportTo__main__Dir)):
            with open(f&#39;{project_dir_path}/requirements-by-{os.path.basename(self.__mainScript.__file__)}.txt&#39;, &#39;w&#39;) as req_file:
                for pkg in reqs:
                    req_file.write(pkg + &#39;\n&#39;)
        else:
            pass
            
        return reqs_dict</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PackageManager.PackageManager.AutoImportMissings"><code class="name flex">
<span>def <span class="ident">AutoImportMissings</span></span>(<span>self, IncludeDynamicImports: bool = True, DeepScan: bool = True, UpgradePIP: bool = False, Verbose: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Automatically analysis '<strong>main</strong>' script, update PIP, and installs required packages if missing.</p>
<h3 id="args">Args:</h3>
<pre><code>- IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
- DeepScan (bool, optional): Scans imported scripts in target script for their own imports. Defaults to True.
- UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages. Defaults to False.
- Verbose (bool, optional): Prints function progress. Defaults to False.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>- bool: returns True if all packages were successfully installed, else, False.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AutoImportMissings(self, IncludeDynamicImports: bool = True, DeepScan: bool = True, UpgradePIP: bool = False, Verbose: bool = False) -&gt; bool:
    &#34;&#34;&#34;
        Automatically analysis &#39;__main__&#39; script, update PIP, and installs required packages if missing.

        ### Args:
            - IncludeDynamicImports (bool, optional): If enabled, packages imported dynamically while the code runs will be collected. Defaults to True.
            - DeepScan (bool, optional): Scans imported scripts in target script for their own imports. Defaults to True.
            - UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages. Defaults to False.
            - Verbose (bool, optional): Prints function progress. Defaults to False.

        ### Returns:
            - bool: returns True if all packages were successfully installed, else, False.
    &#34;&#34;&#34;

    failed_packages = set()

    missing_packages = self.__GetMissingPackages(PackagePath=self.__mainScriptPath, IncludeDynamicImports=IncludeDynamicImports, DeepScan=DeepScan, Verbose=Verbose)

    if (bool(UpgradePIP)): self.__UpgradePIP(Verbose=Verbose)

    for ind, pkg in enumerate(missing_packages, 1):
        if (bool(Verbose)): print(f&#34;\nInstalling Packages {ind}/{len(missing_packages)}&#34;)
        
        retry_counter = 1
        while (retry_counter &gt; 0):
            pkg_installer = self.__InstallPackage(PackageName=pkg, Verbose=Verbose)

            if (pkg_installer[&#39;ExitCode&#39;] == 0):
                if (pkg in failed_packages):
                    failed_packages.remove(pkg)
                else:
                    pass
                
                break

            else:
                retry_counter -= 1
                failed_packages.add(pkg)
    
    if (len(failed_packages) &gt; 0):
        print(f&#39;\nCOULD NOT INSTALL THESE PACKAGES: ({&#34;, &#34;.join(failed_packages)})!\nPLEASE CONSIDER INSTALLING THEM MANUALLY!\n&#39;)

        while True:
            decision = input(&#39;Would you like to continue executing your code? *IT WILL PROBABLY RAISE AN ERROR IF YOU CONTINUE..* (Y/n) &#39;)

            if (decision == &#39;Y&#39;):
                print()
                return False
            elif (decision == &#39;n&#39;):
                exit()
            else:
                print(&#39;Invalid input!&#39;)
    elif (str(missing_packages) == &#39;None&#39;) \
    or (len(missing_packages) == 0):
        print(f&#39;\nNo missing required packages were found!\n&#39;)
    
    else:
        print(f&#39;\nRequired missing packages have been installed successfully!\n&#39;)</code></pre>
</details>
</dd>
<dt id="PackageManager.PackageManager.ExportRequirements"><code class="name flex">
<span>def <span class="ident">ExportRequirements</span></span>(<span>self, ExportTo__main__Dir: str | bool = False) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Exports a requirement file contains modules required by the project which this method is called in.</p>
<h3 id="args">Args:</h3>
<pre><code>- ExportTo__main__Dir (str | bool, optional): This argument has three modes as explained below.

    * Mode 1: If set to bool(False), will not export to file and will only return a dict of packages and their versions. (Default)
    * Mode 2: If set to bool(True), will export requirements.txt file to parent directory of __main__ file.
    * Mode 3: If set to a valid directory str(path), will export requirement.txt to specified directory.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>- dict: Dict of packages names and versions (possible keys for each value =&gt; 'name', 'version')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ExportRequirements(self, ExportTo__main__Dir: str | bool = False) -&gt; dict:
    &#34;&#34;&#34;
        Exports a requirement file contains modules required by the project which this method is called in.

        ### Args:
            - ExportTo__main__Dir (str | bool, optional): This argument has three modes as explained below.\n
                * Mode 1: If set to bool(False), will not export to file and will only return a dict of packages and their versions. (Default)
                * Mode 2: If set to bool(True), will export requirements.txt file to parent directory of __main__ file.
                * Mode 3: If set to a valid directory str(path), will export requirement.txt to specified directory.

        ### Returns:
            - dict: Dict of packages names and versions (possible keys for each value =&gt; &#39;name&#39;, &#39;version&#39;)
    &#34;&#34;&#34;

    project_dir_path = os.path.dirname(self.__mainScriptPath)
    pkgs = self.__GetRequiredPackages(self.__mainScriptPath, DeepScan=True)
    reqs = []

    for pkg in pkgs:
        if project_dir_path not in self.__GetPackagePath(pkg):
            reqs.append(pkg + &#34;==&#34; + importlib.metadata.version(pkg))
        else:
            pass
    
    reqs.insert(0, __name__ + &#39;==&#39; + __version__)
    
    reqs_dict = {pkg: {&#39;name&#39;: pkg, &#39;version&#39;: ver} for pkg, ver in [req.split(&#39;==&#39;) for req in reqs]}

    if (bool(os.path.isdir(ExportTo__main__Dir))):
        project_dir_path = ExportTo__main__Dir.replace(&#39;&#34;&#39;, &#39;&#39;).replace(&#34;&#39;&#34;, &#39;&#39;).replace(&#39;\\&#39;, &#39;/&#39;)
    else:
        pass
        
    
    if (bool(os.path.isdir(project_dir_path))) \
    and (bool(ExportTo__main__Dir)):
        with open(f&#39;{project_dir_path}/requirements-by-{os.path.basename(self.__mainScript.__file__)}.txt&#39;, &#39;w&#39;) as req_file:
            for pkg in reqs:
                req_file.write(pkg + &#39;\n&#39;)
    else:
        pass
        
    return reqs_dict</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PackageManager.PSL" href="#PackageManager.PSL">PSL</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PackageManager.AutoImporter" href="#PackageManager.AutoImporter">AutoImporter</a></code></h4>
</li>
<li>
<h4><code><a title="PackageManager.PackageManager" href="#PackageManager.PackageManager">PackageManager</a></code></h4>
<ul class="">
<li><code><a title="PackageManager.PackageManager.AutoImportMissings" href="#PackageManager.PackageManager.AutoImportMissings">AutoImportMissings</a></code></li>
<li><code><a title="PackageManager.PackageManager.ExportRequirements" href="#PackageManager.PackageManager.ExportRequirements">ExportRequirements</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>