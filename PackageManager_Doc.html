<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"><meta name="generator" content="pdoc 0.10.0"><title>PackageManager API documentation</title><meta name="description" content="Package Manager v1.0.0 â€¦"><link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin><link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin><link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin><style>:root{--highlight-color:#fe9}.flex{display:flex!important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .5em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:700}h2[id^=header-]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:0 0}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}#index,.toc ul{list-style-type:none;margin:0;padding:0}#index code{background:0 0}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:700}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:700;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:700}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.git-link-div,.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:700}.admonition.important,.admonition.info,.admonition.note{background:#aef}.admonition.hint,.admonition.tip,.admonition.todo,.admonition.versionadded{background:#dfd}.admonition.deprecated,.admonition.versionchanged,.admonition.warning{background:#fd4}.admonition.caution,.admonition.danger,.admonition.error{background:#ffb6c1}</style><style media="screen and (min-width:700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}#index ul,.toc ul ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}}</style><style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:0 0!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="#"]:after,a[href^="javascript:"]:after{content:""}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style><script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script><script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script></head><body><main><article id="content"><header><h1 class="title">Module<code>PackageManager</code></h1></header><section id="section-intro"><p>Package Manager v1.0.0</p><p>This module allows you to automatically import missing libraries (modules) that are required by any script without the need to any other installation or a requirement file.</p><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
    Package Manager v1.0.0
    \n
    This module allows you to automatically import missing libraries (modules) that are required
    by any script without the need to any other installation or a requirement file.
&#34;&#34;&#34;

import inspect, pkgutil, subprocess, sys

##################################################
__author__ = &#34;Abdullrahman Elsayed&#34;
__copyright__ = &#34;Copyright 2022, Supportive Python Modules Project&#34;
__credits__ = [__author__]
__license__ = &#34;GPL-2.0&#34;
__version__ = &#34;1.0.0&#34;
__maintainer__ = __author__
__email__ = &#34;abdull15199@gmail.com&#34;
__status__ = &#34;Production&#34;
##################################################

class PackageManager:
    &#34;&#34;&#34;
        Main class of the module.
    &#34;&#34;&#34;
    
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
            Constructor gets the main script file path and store class-scope variables
        &#34;&#34;&#34;

        self.MainScript = sys.modules[&#39;__main__&#39;]
        self.MainScriptPath = str(self.MainScript.__file__)
        self.MainScriptCode = list(inspect.getsourcelines(self.MainScript)[0])
        self.InstalledPackages = list(self.GetImportablePackages())
        self.RequiredPackages = list(self.GetRequiredPackages())

        return None
    
    def GetRequiredPackages(self, Verbose = False) -&gt; list:
        &#34;&#34;&#34;
            Extracts imported packages from __main__ file.

            Args:
                Verbose (bool, optional): Prints function progress. Defaults to False.

            Returns:
                list: Required packages names. 
        &#34;&#34;&#34;
        # Print progress to stdout
        if Verbose: print(&#34;Analyzing Main Script...&#34;)

        # Looing over __main__ source code lines
        required_packages = []
        
        for line in self.MainScriptCode:
            # Remove leading and trailing spaces and line breaksof each line
            line = line.lstrip(&#39; &#39;).rstrip(&#39; &#39;).rstrip(&#39;\n&#39;)
            
            # Selecting only &#39;import&#39; lines
            if line.startswith((&#39;import&#39;, &#39;from&#39;)):
                # Splitting &#39;import_lines&#39; to extract packages names
                line = line.split(&#39; &#39;)
                # Removing commas between multiple one-line imports
                line = [word.replace(&#39;,&#39;, &#39;&#39;) for word in line if word != &#39;,&#39;]
                # Removing spaces and empty elements
                line = [word for word in line if word]
                
                # Extracting packages names from cleaned lines
                # Ignoring &#39;as&#39; synonyms
                if &#39;as&#39; in line:
                    line = line[:line.index(&#39;as&#39;)]
                else:
                    pass
                
                # If packages is imported, not a submodule (e.g. import package)
                if line[0] == &#39;import&#39;:
                    required_packages.extend(line[1:])
                # If a submodule is imported from a package (e.g. from package import module)
                else:
                    required_packages.extend(line[1:line.index(&#39;import&#39;)])
                
        # Collecting only packages names and ignoring submodules names
        required_packages = [pkg.split(&#39;.&#39;)[0] for pkg in required_packages]

        # Extracting only the packages that are not installed and deleting duplicates using &#39;set()&#39;
        required_packages = [pkg for pkg in set(required_packages) if pkg not in self.InstalledPackages]

        ######################## KEEP IT FOR LATER ########################
        # finder_process = modulefinder.ModuleFinder()
        # finder_process.run_script(self.MainScriptPath)
        # imported_packages = list(finder_process.modules[&#39;__main__&#39;].globalnames.keys())
        # required_packages = []
        # for pkg in imported_packages:
        #     if pkg not in self.InstalledPackages:
        #         required_packages.append(pkg)
        ######################## KEEP IT FOR LATER ########################

        return list(required_packages)

    def GetImportablePackages(self, Verbose = False) -&gt; list:
        &#34;&#34;&#34;
            Collects all packages (built-ins &amp; installed) accessible by Python.

            Args:
                Verbose (bool, optional): Prints function progress. Defaults to False.

            Returns:
                list: Names of all accessible packages (installed &amp; built-ins).
        &#34;&#34;&#34;

        # Print progress to stdout
        if Verbose: print(&#34;Collecting Installed Packages...&#34;)

        # Retriving all &#39;sys&#39; accessible packages
        packages = list(sys.modules) + list(sys.builtin_module_names) + list(sys.stdlib_module_names)

        # Retriving other packages inaccessible by &#39;sys&#39;
        # Collect package names using &#39;..iter_modules()&#39;
        # Do not use &#39;..walk_packages()&#39;; it is slower than &#39;..iter_modules()&#39; because it retrives submodules as well
        # &#39;pkgutil.walk_packages()&#39; returns objects of modules, so we need to collect &#39;pkg.name&#39;
        for pkg in pkgutil.iter_modules():
            packages.append(pkg.name)
        
        # Sorting and setting packages names to remove duplicate names
        packages = sorted(set(packages))

        return list(packages)

    def InstallPackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False) -&gt; dict:
        &#34;&#34;&#34;
            Installs specific package with desired version. If &#39;PackageVersion&#39; == None -&gt; latest version will be installed.

            Args:
                PackageName (str): Exact package name to be installed.
                PackageVersion (str, optional): Exact package version to be installed. Comparator operators are not allowed! Defaults to &#34;latest&#34;.
                Verbose (bool, optional): Prints function progress.

            Returns:
                dict: Returns a dict; keys = ReturnMessage, ExitCode, ExitMessage
        &#34;&#34;&#34;

        # Check package version to be installed
        if PackageVersion.replace(&#39;.&#39;,&#39;&#39;).isdigit():
            target_package = f&#39;{str(PackageName)}=={str(PackageVersion)}&#39;
        else:
            target_package = str(PackageName)

        # Print progress to stdout
        if Verbose: print(f&#39;Attempting to install &#34;{target_package}&#34;...&#39;)

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        installation_command = f&#39;&#34;{sys.executable}&#34; -m pip install {str(target_package)}&#39;
        installation_process = subprocess.Popen(str(installation_command), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return messages from executed command
        execution_message = str(installation_process.communicate())
        execution_exit_code = int(installation_process.wait())

        # Define function return messages based on execution return message
        if execution_exit_code == 0:    # 0 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; is already installed or has been installed successfully!&#39;
        elif execution_exit_code == 1:  # 1 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; was not recognized, please consider installing it manually!&#39;
        else:                           # Other -&gt; Unknown Exit Code
            return_message = f&#39;Unexpected exit code ({execution_exit_code}) returned while installing &#34;{target_package}&#34;&#39;

        # Print progress to stdout
        if Verbose: print(return_message)
        
        return dict(
                {
                &#34;ReturnMessage&#34; : return_message,
                &#34;ExitCode&#34;      : execution_exit_code,
                &#34;ExitMessage&#34;   : execution_message
                }
            )

    def UpgradePIP(self, Verbose = False) -&gt; int:
        &#34;&#34;&#34;
            Upgrade pip if an upgrade is available.

            Args:
                Verbose (bool, optional): Prints function progress.

            Returns:
                int: Exit Code {
                    0 : Successfully upgraded | No new version available
                    1 : An error occured
                    2 : Unknown exit code
                }
        &#34;&#34;&#34;

        # Print progress to stdout
        if Verbose: print(f&#39;Attempting to upgrade pip...&#39;)

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip install --upgrade pip&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return code from executed command
        execution_exit_code = int(execution.wait())
        
        # Define function return messages based on execution return message
        if execution_exit_code == 0:    # 0 -&gt; Successful Exit Code
            return_code = 0
            return_message = &#39;pip is already latest or has been upgraded successfuly!&#39;
        elif execution_exit_code == 1:  # 1 -&gt; Error Exit Code
            return_code = 1
            return_message = &#39;pip was not upgraded, please consider upgrading pip manually!&#39;
        else:                           # Other -&gt; Unknown Exit Code
            return_code = 2
            return_message = &#39;Unexpected exit code!&#39;
        
        # Print progress to stdout
        if Verbose: print(return_message)

        return int(return_code)

    def LetMeRelax(self, UpgradePIP = False, Verbose = False) -&gt; bool:
        &#34;&#34;&#34;
            Automatically analysis &#39;__main__&#39; script, update PIP, and installs required packages if missing.

            Args:
                UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages.
                Verbose (bool, optional): Prints function progress.

            Returns:
                bool: returns True if all packages were successfully installed, else, False.
        &#34;&#34;&#34;

        failed_packages = []

        if len(self.RequiredPackages) != 0:
            if UpgradePIP: self.UpgradePIP(Verbose=Verbose)

            retry_counter = 3

            while retry_counter:

                for ind, pkg in enumerate(self.RequiredPackages, 1):
                    if Verbose: print(f&#34;\nInstalling Packages {ind}/{len(self.RequiredPackages)}&#34;)
                    
                    pkg_installer = self.InstallPackage(PackageName=pkg, Verbose=Verbose)

                    if pkg_installer[&#39;ExitCode&#39;] != 0:
                        if pkg in failed_packages:
                            pass
                        else:
                            failed_packages.append(pkg)
                
                if len(failed_packages) == 0:
                    break
                else:
                    retry_counter -= 1

            if len(failed_packages) != 0:
                print(f&#39;\nCOULD NOT INSTALL THESE PACKAGES: {&#34;, &#34;.join(failed_packages)}!\nPLEASE CONSIDER INSTALLING THEM MANUALLY!\n&#39;)

                while True:
                    decision = input(&#39;Would you like to continue executing your code? *IT WILL PROBABLY RAISE AN ERROR IF YOU CONTINUE..* (Y/n) &#39;)

                    if decision == &#39;Y&#39;:
                        print()
                        return False
                    elif decision == &#39;n&#39;:
                        exit()
                    else:
                        pass
            else:
                print()
                return True
        
        else:
            return True

# Setup auto importer
if __name__ != &#39;__main__&#39;:
    PackageManager().LetMeRelax(UpgradePIP=True, Verbose=False)</code></pre></details></section><section></section><section></section><section></section><section><h2 class="section-title" id="header-classes">Classes</h2><dl><dt id="PackageManager.PackageManager"><code class="flex name class"><span>class<span class="ident">PackageManager</span></span></code></dt><dd><div class="desc"><p>Main class of the module.</p><p>Constructor gets the main script file path and store class-scope variables</p></div><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">class PackageManager:
    &#34;&#34;&#34;
        Main class of the module.
    &#34;&#34;&#34;
    
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
            Constructor gets the main script file path and store class-scope variables
        &#34;&#34;&#34;

        self.MainScript = sys.modules[&#39;__main__&#39;]
        self.MainScriptPath = str(self.MainScript.__file__)
        self.MainScriptCode = list(inspect.getsourcelines(self.MainScript)[0])
        self.InstalledPackages = list(self.GetImportablePackages())
        self.RequiredPackages = list(self.GetRequiredPackages())

        return None
    
    def GetRequiredPackages(self, Verbose = False) -&gt; list:
        &#34;&#34;&#34;
            Extracts imported packages from __main__ file.

            Args:
                Verbose (bool, optional): Prints function progress. Defaults to False.

            Returns:
                list: Required packages names. 
        &#34;&#34;&#34;
        # Print progress to stdout
        if Verbose: print(&#34;Analyzing Main Script...&#34;)

        # Looing over __main__ source code lines
        required_packages = []
        
        for line in self.MainScriptCode:
            # Remove leading and trailing spaces and line breaksof each line
            line = line.lstrip(&#39; &#39;).rstrip(&#39; &#39;).rstrip(&#39;\n&#39;)
            
            # Selecting only &#39;import&#39; lines
            if line.startswith((&#39;import&#39;, &#39;from&#39;)):
                # Splitting &#39;import_lines&#39; to extract packages names
                line = line.split(&#39; &#39;)
                # Removing commas between multiple one-line imports
                line = [word.replace(&#39;,&#39;, &#39;&#39;) for word in line if word != &#39;,&#39;]
                # Removing spaces and empty elements
                line = [word for word in line if word]
                
                # Extracting packages names from cleaned lines
                # Ignoring &#39;as&#39; synonyms
                if &#39;as&#39; in line:
                    line = line[:line.index(&#39;as&#39;)]
                else:
                    pass
                
                # If packages is imported, not a submodule (e.g. import package)
                if line[0] == &#39;import&#39;:
                    required_packages.extend(line[1:])
                # If a submodule is imported from a package (e.g. from package import module)
                else:
                    required_packages.extend(line[1:line.index(&#39;import&#39;)])
                
        # Collecting only packages names and ignoring submodules names
        required_packages = [pkg.split(&#39;.&#39;)[0] for pkg in required_packages]

        # Extracting only the packages that are not installed and deleting duplicates using &#39;set()&#39;
        required_packages = [pkg for pkg in set(required_packages) if pkg not in self.InstalledPackages]

        ######################## KEEP IT FOR LATER ########################
        # finder_process = modulefinder.ModuleFinder()
        # finder_process.run_script(self.MainScriptPath)
        # imported_packages = list(finder_process.modules[&#39;__main__&#39;].globalnames.keys())
        # required_packages = []
        # for pkg in imported_packages:
        #     if pkg not in self.InstalledPackages:
        #         required_packages.append(pkg)
        ######################## KEEP IT FOR LATER ########################

        return list(required_packages)

    def GetImportablePackages(self, Verbose = False) -&gt; list:
        &#34;&#34;&#34;
            Collects all packages (built-ins &amp; installed) accessible by Python.

            Args:
                Verbose (bool, optional): Prints function progress. Defaults to False.

            Returns:
                list: Names of all accessible packages (installed &amp; built-ins).
        &#34;&#34;&#34;

        # Print progress to stdout
        if Verbose: print(&#34;Collecting Installed Packages...&#34;)

        # Retriving all &#39;sys&#39; accessible packages
        packages = list(sys.modules) + list(sys.builtin_module_names) + list(sys.stdlib_module_names)

        # Retriving other packages inaccessible by &#39;sys&#39;
        # Collect package names using &#39;..iter_modules()&#39;
        # Do not use &#39;..walk_packages()&#39;; it is slower than &#39;..iter_modules()&#39; because it retrives submodules as well
        # &#39;pkgutil.walk_packages()&#39; returns objects of modules, so we need to collect &#39;pkg.name&#39;
        for pkg in pkgutil.iter_modules():
            packages.append(pkg.name)
        
        # Sorting and setting packages names to remove duplicate names
        packages = sorted(set(packages))

        return list(packages)

    def InstallPackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False) -&gt; dict:
        &#34;&#34;&#34;
            Installs specific package with desired version. If &#39;PackageVersion&#39; == None -&gt; latest version will be installed.

            Args:
                PackageName (str): Exact package name to be installed.
                PackageVersion (str, optional): Exact package version to be installed. Comparator operators are not allowed! Defaults to &#34;latest&#34;.
                Verbose (bool, optional): Prints function progress.

            Returns:
                dict: Returns a dict; keys = ReturnMessage, ExitCode, ExitMessage
        &#34;&#34;&#34;

        # Check package version to be installed
        if PackageVersion.replace(&#39;.&#39;,&#39;&#39;).isdigit():
            target_package = f&#39;{str(PackageName)}=={str(PackageVersion)}&#39;
        else:
            target_package = str(PackageName)

        # Print progress to stdout
        if Verbose: print(f&#39;Attempting to install &#34;{target_package}&#34;...&#39;)

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        installation_command = f&#39;&#34;{sys.executable}&#34; -m pip install {str(target_package)}&#39;
        installation_process = subprocess.Popen(str(installation_command), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return messages from executed command
        execution_message = str(installation_process.communicate())
        execution_exit_code = int(installation_process.wait())

        # Define function return messages based on execution return message
        if execution_exit_code == 0:    # 0 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; is already installed or has been installed successfully!&#39;
        elif execution_exit_code == 1:  # 1 -&gt; Successful Exit Code
            return_message = f&#39;&#34;{target_package}&#34; was not recognized, please consider installing it manually!&#39;
        else:                           # Other -&gt; Unknown Exit Code
            return_message = f&#39;Unexpected exit code ({execution_exit_code}) returned while installing &#34;{target_package}&#34;&#39;

        # Print progress to stdout
        if Verbose: print(return_message)
        
        return dict(
                {
                &#34;ReturnMessage&#34; : return_message,
                &#34;ExitCode&#34;      : execution_exit_code,
                &#34;ExitMessage&#34;   : execution_message
                }
            )

    def UpgradePIP(self, Verbose = False) -&gt; int:
        &#34;&#34;&#34;
            Upgrade pip if an upgrade is available.

            Args:
                Verbose (bool, optional): Prints function progress.

            Returns:
                int: Exit Code {
                    0 : Successfully upgraded | No new version available
                    1 : An error occured
                    2 : Unknown exit code
                }
        &#34;&#34;&#34;

        # Print progress to stdout
        if Verbose: print(f&#39;Attempting to upgrade pip...&#39;)

        # Setup a command to install the package
        # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
        execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip install --upgrade pip&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Collect return code from executed command
        execution_exit_code = int(execution.wait())
        
        # Define function return messages based on execution return message
        if execution_exit_code == 0:    # 0 -&gt; Successful Exit Code
            return_code = 0
            return_message = &#39;pip is already latest or has been upgraded successfuly!&#39;
        elif execution_exit_code == 1:  # 1 -&gt; Error Exit Code
            return_code = 1
            return_message = &#39;pip was not upgraded, please consider upgrading pip manually!&#39;
        else:                           # Other -&gt; Unknown Exit Code
            return_code = 2
            return_message = &#39;Unexpected exit code!&#39;
        
        # Print progress to stdout
        if Verbose: print(return_message)

        return int(return_code)

    def LetMeRelax(self, UpgradePIP = False, Verbose = False) -&gt; bool:
        &#34;&#34;&#34;
            Automatically analysis &#39;__main__&#39; script, update PIP, and installs required packages if missing.

            Args:
                UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages.
                Verbose (bool, optional): Prints function progress.

            Returns:
                bool: returns True if all packages were successfully installed, else, False.
        &#34;&#34;&#34;

        failed_packages = []

        if len(self.RequiredPackages) != 0:
            if UpgradePIP: self.UpgradePIP(Verbose=Verbose)

            retry_counter = 3

            while retry_counter:

                for ind, pkg in enumerate(self.RequiredPackages, 1):
                    if Verbose: print(f&#34;\nInstalling Packages {ind}/{len(self.RequiredPackages)}&#34;)
                    
                    pkg_installer = self.InstallPackage(PackageName=pkg, Verbose=Verbose)

                    if pkg_installer[&#39;ExitCode&#39;] != 0:
                        if pkg in failed_packages:
                            pass
                        else:
                            failed_packages.append(pkg)
                
                if len(failed_packages) == 0:
                    break
                else:
                    retry_counter -= 1

            if len(failed_packages) != 0:
                print(f&#39;\nCOULD NOT INSTALL THESE PACKAGES: {&#34;, &#34;.join(failed_packages)}!\nPLEASE CONSIDER INSTALLING THEM MANUALLY!\n&#39;)

                while True:
                    decision = input(&#39;Would you like to continue executing your code? *IT WILL PROBABLY RAISE AN ERROR IF YOU CONTINUE..* (Y/n) &#39;)

                    if decision == &#39;Y&#39;:
                        print()
                        return False
                    elif decision == &#39;n&#39;:
                        exit()
                    else:
                        pass
            else:
                print()
                return True
        
        else:
            return True</code></pre></details><h3>Methods</h3><dl><dt id="PackageManager.PackageManager.GetImportablePackages"><code class="name flex"><span>def<span class="ident">GetImportablePackages</span></span>(<span>self, Verbose=False) â€‘>Â list</span></code></dt><dd><div class="desc"><p>Collects all packages (built-ins &amp; installed) accessible by Python.</p><h2 id="args">Args</h2><dl><dt><strong><code>Verbose</code></strong>:&ensp;<code>bool</code>, optional</dt><dd>Prints function progress. Defaults to False.</dd></dl><h2 id="returns">Returns</h2><dl><dt><code>list</code></dt><dd>Names of all accessible packages (installed &amp; built-ins).</dd></dl></div><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">def GetImportablePackages(self, Verbose = False) -&gt; list:
    &#34;&#34;&#34;
        Collects all packages (built-ins &amp; installed) accessible by Python.

        Args:
            Verbose (bool, optional): Prints function progress. Defaults to False.

        Returns:
            list: Names of all accessible packages (installed &amp; built-ins).
    &#34;&#34;&#34;

    # Print progress to stdout
    if Verbose: print(&#34;Collecting Installed Packages...&#34;)

    # Retriving all &#39;sys&#39; accessible packages
    packages = list(sys.modules) + list(sys.builtin_module_names) + list(sys.stdlib_module_names)

    # Retriving other packages inaccessible by &#39;sys&#39;
    # Collect package names using &#39;..iter_modules()&#39;
    # Do not use &#39;..walk_packages()&#39;; it is slower than &#39;..iter_modules()&#39; because it retrives submodules as well
    # &#39;pkgutil.walk_packages()&#39; returns objects of modules, so we need to collect &#39;pkg.name&#39;
    for pkg in pkgutil.iter_modules():
        packages.append(pkg.name)
    
    # Sorting and setting packages names to remove duplicate names
    packages = sorted(set(packages))

    return list(packages)</code></pre></details></dd><dt id="PackageManager.PackageManager.GetRequiredPackages"><code class="name flex"><span>def<span class="ident">GetRequiredPackages</span></span>(<span>self, Verbose=False) â€‘>Â list</span></code></dt><dd><div class="desc"><p>Extracts imported packages from<strong>main</strong>file.</p><h2 id="args">Args</h2><dl><dt><strong><code>Verbose</code></strong>:&ensp;<code>bool</code>, optional</dt><dd>Prints function progress. Defaults to False.</dd></dl><h2 id="returns">Returns</h2><dl><dt><code>list</code></dt><dd>Required packages names.</dd></dl></div><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">def GetRequiredPackages(self, Verbose = False) -&gt; list:
    &#34;&#34;&#34;
        Extracts imported packages from __main__ file.

        Args:
            Verbose (bool, optional): Prints function progress. Defaults to False.

        Returns:
            list: Required packages names. 
    &#34;&#34;&#34;
    # Print progress to stdout
    if Verbose: print(&#34;Analyzing Main Script...&#34;)

    # Looing over __main__ source code lines
    required_packages = []
    
    for line in self.MainScriptCode:
        # Remove leading and trailing spaces and line breaksof each line
        line = line.lstrip(&#39; &#39;).rstrip(&#39; &#39;).rstrip(&#39;\n&#39;)
        
        # Selecting only &#39;import&#39; lines
        if line.startswith((&#39;import&#39;, &#39;from&#39;)):
            # Splitting &#39;import_lines&#39; to extract packages names
            line = line.split(&#39; &#39;)
            # Removing commas between multiple one-line imports
            line = [word.replace(&#39;,&#39;, &#39;&#39;) for word in line if word != &#39;,&#39;]
            # Removing spaces and empty elements
            line = [word for word in line if word]
            
            # Extracting packages names from cleaned lines
            # Ignoring &#39;as&#39; synonyms
            if &#39;as&#39; in line:
                line = line[:line.index(&#39;as&#39;)]
            else:
                pass
            
            # If packages is imported, not a submodule (e.g. import package)
            if line[0] == &#39;import&#39;:
                required_packages.extend(line[1:])
            # If a submodule is imported from a package (e.g. from package import module)
            else:
                required_packages.extend(line[1:line.index(&#39;import&#39;)])
            
    # Collecting only packages names and ignoring submodules names
    required_packages = [pkg.split(&#39;.&#39;)[0] for pkg in required_packages]

    # Extracting only the packages that are not installed and deleting duplicates using &#39;set()&#39;
    required_packages = [pkg for pkg in set(required_packages) if pkg not in self.InstalledPackages]

    ######################## KEEP IT FOR LATER ########################
    # finder_process = modulefinder.ModuleFinder()
    # finder_process.run_script(self.MainScriptPath)
    # imported_packages = list(finder_process.modules[&#39;__main__&#39;].globalnames.keys())
    # required_packages = []
    # for pkg in imported_packages:
    #     if pkg not in self.InstalledPackages:
    #         required_packages.append(pkg)
    ######################## KEEP IT FOR LATER ########################

    return list(required_packages)</code></pre></details></dd><dt id="PackageManager.PackageManager.InstallPackage"><code class="name flex"><span>def<span class="ident">InstallPackage</span></span>(<span>self, PackageName:Â str, PackageVersion='latest', Verbose=False) â€‘>Â dict</span></code></dt><dd><div class="desc"><p>Installs specific package with desired version. If 'PackageVersion' == None -&gt; latest version will be installed.</p><h2 id="args">Args</h2><dl><dt><strong><code>PackageName</code></strong>:&ensp;<code>str</code></dt><dd>Exact package name to be installed.</dd><dt><strong><code>PackageVersion</code></strong>:&ensp;<code>str</code>, optional</dt><dd>Exact package version to be installed. Comparator operators are not allowed! Defaults to "latest".</dd><dt><strong><code>Verbose</code></strong>:&ensp;<code>bool</code>, optional</dt><dd>Prints function progress.</dd></dl><h2 id="returns">Returns</h2><dl><dt><code>dict</code></dt><dd>Returns a dict; keys = ReturnMessage, ExitCode, ExitMessage</dd></dl></div><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">def InstallPackage(self, PackageName: str, PackageVersion = &#34;latest&#34;, Verbose = False) -&gt; dict:
    &#34;&#34;&#34;
        Installs specific package with desired version. If &#39;PackageVersion&#39; == None -&gt; latest version will be installed.

        Args:
            PackageName (str): Exact package name to be installed.
            PackageVersion (str, optional): Exact package version to be installed. Comparator operators are not allowed! Defaults to &#34;latest&#34;.
            Verbose (bool, optional): Prints function progress.

        Returns:
            dict: Returns a dict; keys = ReturnMessage, ExitCode, ExitMessage
    &#34;&#34;&#34;

    # Check package version to be installed
    if PackageVersion.replace(&#39;.&#39;,&#39;&#39;).isdigit():
        target_package = f&#39;{str(PackageName)}=={str(PackageVersion)}&#39;
    else:
        target_package = str(PackageName)

    # Print progress to stdout
    if Verbose: print(f&#39;Attempting to install &#34;{target_package}&#34;...&#39;)

    # Setup a command to install the package
    # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
    installation_command = f&#39;&#34;{sys.executable}&#34; -m pip install {str(target_package)}&#39;
    installation_process = subprocess.Popen(str(installation_command), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    # Collect return messages from executed command
    execution_message = str(installation_process.communicate())
    execution_exit_code = int(installation_process.wait())

    # Define function return messages based on execution return message
    if execution_exit_code == 0:    # 0 -&gt; Successful Exit Code
        return_message = f&#39;&#34;{target_package}&#34; is already installed or has been installed successfully!&#39;
    elif execution_exit_code == 1:  # 1 -&gt; Successful Exit Code
        return_message = f&#39;&#34;{target_package}&#34; was not recognized, please consider installing it manually!&#39;
    else:                           # Other -&gt; Unknown Exit Code
        return_message = f&#39;Unexpected exit code ({execution_exit_code}) returned while installing &#34;{target_package}&#34;&#39;

    # Print progress to stdout
    if Verbose: print(return_message)
    
    return dict(
            {
            &#34;ReturnMessage&#34; : return_message,
            &#34;ExitCode&#34;      : execution_exit_code,
            &#34;ExitMessage&#34;   : execution_message
            }
        )</code></pre></details></dd><dt id="PackageManager.PackageManager.LetMeRelax"><code class="name flex"><span>def<span class="ident">LetMeRelax</span></span>(<span>self, UpgradePIP=False, Verbose=False) â€‘>Â bool</span></code></dt><dd><div class="desc"><p>Automatically analysis '<strong>main</strong>' script, update PIP, and installs required packages if missing.</p><h2 id="args">Args</h2><dl><dt><strong><code>UpgradePIP</code></strong>:&ensp;<code>bool</code>, optional</dt><dd>Optionally upgrade PIP before installing required packages.</dd><dt><strong><code>Verbose</code></strong>:&ensp;<code>bool</code>, optional</dt><dd>Prints function progress.</dd></dl><h2 id="returns">Returns</h2><dl><dt><code>bool</code></dt><dd>returns True if all packages were successfully installed, else, False.</dd></dl></div><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">def LetMeRelax(self, UpgradePIP = False, Verbose = False) -&gt; bool:
    &#34;&#34;&#34;
        Automatically analysis &#39;__main__&#39; script, update PIP, and installs required packages if missing.

        Args:
            UpgradePIP (bool, optional): Optionally upgrade PIP before installing required packages.
            Verbose (bool, optional): Prints function progress.

        Returns:
            bool: returns True if all packages were successfully installed, else, False.
    &#34;&#34;&#34;

    failed_packages = []

    if len(self.RequiredPackages) != 0:
        if UpgradePIP: self.UpgradePIP(Verbose=Verbose)

        retry_counter = 3

        while retry_counter:

            for ind, pkg in enumerate(self.RequiredPackages, 1):
                if Verbose: print(f&#34;\nInstalling Packages {ind}/{len(self.RequiredPackages)}&#34;)
                
                pkg_installer = self.InstallPackage(PackageName=pkg, Verbose=Verbose)

                if pkg_installer[&#39;ExitCode&#39;] != 0:
                    if pkg in failed_packages:
                        pass
                    else:
                        failed_packages.append(pkg)
            
            if len(failed_packages) == 0:
                break
            else:
                retry_counter -= 1

        if len(failed_packages) != 0:
            print(f&#39;\nCOULD NOT INSTALL THESE PACKAGES: {&#34;, &#34;.join(failed_packages)}!\nPLEASE CONSIDER INSTALLING THEM MANUALLY!\n&#39;)

            while True:
                decision = input(&#39;Would you like to continue executing your code? *IT WILL PROBABLY RAISE AN ERROR IF YOU CONTINUE..* (Y/n) &#39;)

                if decision == &#39;Y&#39;:
                    print()
                    return False
                elif decision == &#39;n&#39;:
                    exit()
                else:
                    pass
        else:
            print()
            return True
    
    else:
        return True</code></pre></details></dd><dt id="PackageManager.PackageManager.UpgradePIP"><code class="name flex"><span>def<span class="ident">UpgradePIP</span></span>(<span>self, Verbose=False) â€‘>Â int</span></code></dt><dd><div class="desc"><p>Upgrade pip if an upgrade is available.</p><h2 id="args">Args</h2><dl><dt><strong><code>Verbose</code></strong>:&ensp;<code>bool</code>, optional</dt><dd>Prints function progress.</dd></dl><h2 id="returns">Returns</h2><dl><dt><code>int</code></dt><dd>Exit Code { 0 : Successfully upgraded | No new version available 1 : An error occured 2 : Unknown exit code</dd></dl><p>}</p></div><details class="source"><summary><span>Expand source code</span></summary><pre><code class="python">def UpgradePIP(self, Verbose = False) -&gt; int:
    &#34;&#34;&#34;
        Upgrade pip if an upgrade is available.

        Args:
            Verbose (bool, optional): Prints function progress.

        Returns:
            int: Exit Code {
                0 : Successfully upgraded | No new version available
                1 : An error occured
                2 : Unknown exit code
            }
    &#34;&#34;&#34;

    # Print progress to stdout
    if Verbose: print(f&#39;Attempting to upgrade pip...&#39;)

    # Setup a command to install the package
    # Using &#39;sys.executable&#39; to ensure that we install the package for the same version and location of running Python
    execution = subprocess.Popen(f&#39;&#34;{sys.executable}&#34; -m pip install --upgrade pip&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    # Collect return code from executed command
    execution_exit_code = int(execution.wait())
    
    # Define function return messages based on execution return message
    if execution_exit_code == 0:    # 0 -&gt; Successful Exit Code
        return_code = 0
        return_message = &#39;pip is already latest or has been upgraded successfuly!&#39;
    elif execution_exit_code == 1:  # 1 -&gt; Error Exit Code
        return_code = 1
        return_message = &#39;pip was not upgraded, please consider upgrading pip manually!&#39;
    else:                           # Other -&gt; Unknown Exit Code
        return_code = 2
        return_message = &#39;Unexpected exit code!&#39;
    
    # Print progress to stdout
    if Verbose: print(return_message)

    return int(return_code)</code></pre></details></dd></dl></dd></dl></section></article><nav id="sidebar"><h1>Index</h1><div class="toc"><ul></ul></div><ul id="index"><li><h3><a href="#header-classes">Classes</a></h3><ul><li><h4><code><a title="PackageManager.PackageManager" href="#PackageManager.PackageManager">PackageManager</a></code></h4><ul class=""><li><code><a title="PackageManager.PackageManager.GetImportablePackages" href="#PackageManager.PackageManager.GetImportablePackages">GetImportablePackages</a></code></li><li><code><a title="PackageManager.PackageManager.GetRequiredPackages" href="#PackageManager.PackageManager.GetRequiredPackages">GetRequiredPackages</a></code></li><li><code><a title="PackageManager.PackageManager.InstallPackage" href="#PackageManager.PackageManager.InstallPackage">InstallPackage</a></code></li><li><code><a title="PackageManager.PackageManager.LetMeRelax" href="#PackageManager.PackageManager.LetMeRelax">LetMeRelax</a></code></li><li><code><a title="PackageManager.PackageManager.UpgradePIP" href="#PackageManager.PackageManager.UpgradePIP">UpgradePIP</a></code></li></ul></li></ul></li></ul></nav></main><footer id="footer"><p>Generated by<a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite>0.10.0</a>.</p></footer></body></html>